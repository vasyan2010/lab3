#include  <stdio.h>
#include  <windows.h>
#include  <conio.h>
#include  <stdlib.h>
#include  <ctype.h>
#include  <string.h>
#include  <iostream>
using namespace std;

class haf_Tree{   
	private:
		
		struct bit //������ ���
		{
			bit *next; 	//����� �� ���� ������� ������ ���
			bool data;		//0 ��� 1
		};
		
		struct kode //������������� ������ ����� � ���� ������
		{
			kode* next;
			char name;	
			bit * bitHead;
		};	
		
		//������� ������
		class node
		{
			public:	
				char name;	 
				node *rht;
				node *lft;
				node *prnt;
				unsigned int frequency;   		//������
				node *next; 					//��� ������ �� ������� (����� �� ������������ 2 ��������� ������ �� 3) 
				
				node(int nodeFrequency, char nodeName[],int startName)			//����������� 
				{ 
					frequency=nodeFrequency;
					rht=NULL;
					lft=NULL;
					prnt=NULL;
					next=NULL;
					name=nodeName[startName];
				};
				
				node(node * son1, node * son2)			//����������� ��������
				{ 
					frequency=son1->frequency + son2->frequency;
					name='\0';
					rht=son1;
					lft=son2;
					son1->prnt=this;
					son2->prnt=this;
					prnt=NULL;
					next=NULL; //� ����� ���������� ���������� �� �������
				};
				~node(){};

		};
		bit *bitHead; //������ ��� ������ �����
		kode *kodeHead;
		node *leafHead;					
	public:
		haf_Tree()			//����������� 
		{ 
			bitHead=NULL;
			kodeHead=NULL;
			leafHead=NULL;
		};
		~haf_Tree(){};
		
		void makeTree (char input[], int sizeInput)
		{
			char differentCharacters[sizeInput]; 	//��������� ������� �� ������ (����� ������ ������� - ��� ������� ������)
			for (int i=0;i<sizeInput;i++)
				differentCharacters[i]='\0';
			
			/* ��������� ������ differentCharacters */
			int difCarSize=0; //������� ��� ������� differentCharacters
			for (int i=0;i<sizeInput;i++)
			{
				bool uniqueness=true; 	//������������ �������
				for (int j=0;(j<sizeInput)&&(uniqueness);j++)
				{
					if (input[i]==differentCharacters[j])		//����� ��������, �.�. � ������ \0 �� sizeInput+1 (� ���������� ������ sizeInput)
						uniqueness=false;
				}
				if 	(uniqueness)	
				{
					differentCharacters[difCarSize]=input[i];
					difCarSize++;
				}		
			}
			
			unsigned int frequency[difCarSize]; 		//������� ������� ��������
			for (int i=0;i<difCarSize;i++) 
				frequency[i]=0;
				
			/* ��������� ������ frequency (�������) */
			for (int i=0;i<difCarSize;i++)
			{
				for (int j=0;j<sizeInput;j++)
				{
					if (differentCharacters[i]==input[j])
						frequency[i]++;
				}
			}
			
			cout <<"��������� ������: "<<input<<endl;
			cout <<"����� ������: "<<sizeInput<<endl;
		//	cout<<"�"<<difCarSize
			cout <<"���������� ������: "<<sizeInput<<" * 8"<<" = "<<sizeInput*8<<endl;
			
			/*��������� ������ �� �������� � ������ ������� */
			node *nodeHead;
			node *pointerToNext=NULL;
			node  *newLeafPointer;
			for (int i=0;i<difCarSize;i++)
			{
				/* ������� ����� ���� */	
				newLeafPointer= new node(frequency[i],differentCharacters,i);  																			
				/* ��������� ����� */
				newLeafPointer->next=pointerToNext;																									
				pointerToNext=newLeafPointer;																										
			}
			nodeHead=pointerToNext;
		
			/* � ����� ������� ����� �������� ������, �������� ������ ��� ����� ������ �� 1 (��������� ������ 1 �������) */
			node *deletingNode1;	
			node *deletingNode2;
			node *comparedNode;
			node *tmpNode;
			while(nodeHead->next!=NULL)	//���� ��� ���������� ����� ������
			{
				// ������������ ��� ������ ��� �������� ����� ��� ����� ��������� ������  deletingNode2 ������ ������ deletingNode1
				if (nodeHead->frequency<(nodeHead->next->frequency)) //���� ������ ������ �������
				{
					deletingNode1=nodeHead->next;
					deletingNode2=nodeHead;
				}
				else
				{
					deletingNode2=nodeHead->next;
					deletingNode1=nodeHead;
				}
				comparedNode=nodeHead->next->next;
      			//���� ���������� ����� ��������� ������\n";
				while(comparedNode!=NULL)
					{
						if (deletingNode1->frequency>comparedNode->frequency)
						{
							if(deletingNode2->frequency>comparedNode->frequency)
							{
								tmpNode=deletingNode2;
								deletingNode2=comparedNode;
								deletingNode1=tmpNode;
							}
							else
							{
								deletingNode1=comparedNode;
							}
						}
						comparedNode=comparedNode->next;		
					}
				//  ������� ������� � ����� � ����� �������� (� ��� ������ ������� �� ������)
				node * addNode= new node(deletingNode1,deletingNode2); 
				addNode->next=nodeHead;
				nodeHead=addNode;
				//������� ������ �������� ������
				deleteNodeFromList(deletingNode1,nodeHead);
				deleteNodeFromList(deletingNode2,nodeHead);

			}

			//  ����������� ���� ( ��� 0, � ��� 1 �� �������������)
			enterKeys(nodeHead->rht,1);
			enterKeys(nodeHead->lft,0);
			
			//����� �� ����� ���������� ������
			cout<<"���� ��������:\n";
			kode *tmpKode=kodeHead;
			while(tmpKode!=NULL)
			{
				bit * tmpBit = tmpKode->bitHead;
				cout<<"| "<<tmpKode->name<<" | ";
				while(tmpBit!=NULL)
				{
					printf("%d",((tmpBit->data==true)?1:0));
					tmpBit=tmpBit->next;
				}
				cout<<endl;
				tmpKode=tmpKode->next;
			}
			
			int encryptedStringSize=0;
			cout<<"������������� ������:";
			for(int i=0;i<sizeInput;i++)
			{
				tmpKode=kodeHead;
				while(tmpKode->name!=input[i])
					tmpKode=tmpKode->next;
				bit * tmpBit = tmpKode->bitHead;
				while(tmpBit!=NULL)
				{
					printf("%d",((tmpBit->data==true)?1:0));
					encryptedStringSize++;
					tmpBit=tmpBit->next;
				}	
			}
			cout<<endl;
			cout <<"����� ������: "<<encryptedStringSize<<endl;
			cout <<"���������� ������: "<<encryptedStringSize<<" * 1"<<" = "<<encryptedStringSize<<endl;
		//	cout <<"���������� ������: "<<sizeInput<<" * 8"<<" = "<<sizeInput*8<<endl;
			cout<<"������ �����������: "<<sizeInput*8<<" - "<<encryptedStringSize<<" = "<<sizeInput*8-encryptedStringSize<<endl;
		}		
		
		void enterKeys(node *n,bool key) //n-��������������� � ������ ������ ���� ������
		{
		   	if (n!=NULL) //���� �� ���� ������
		  	{		  				  		
		   		bit * newBit= new bit;		//������� ����� ������� ������ ���
		   		newBit->data=key;			//� ������ ������� ������ ��� ������� �������� key
		   		newBit->next=bitHead;		//������ ����� ������� ������ � ������ ���
		   		bitHead=newBit;
		   		if (n->rht!=NULL) 			//���� ������� ������ �� ����, �� ��������� �������� ��� ������� 
		   		{
		   			enterKeys(n->rht,1);
			      	enterKeys(n->lft,0);
				}
				else						//���� ��� ����, �� �������� ������ ��� � kode
				{
			   		kode * newKode=new kode;	//������� ����� ������� kode
			   		newKode->next=kodeHead;		//������ ��� ������
			   		kodeHead=newKode;
			   		newKode->name=n->name;		
			   		bit * tmp=bitHead;
			   		bit * bitHeadCopy=NULL;
			   		while (tmp!=NULL)
			   		{
			   			bit * bitCopy=new bit;
			   			bitCopy->data=tmp->data;
			   			bitCopy->next=bitHeadCopy;
			   			bitHeadCopy=bitCopy;
			   		    tmp=tmp->next;
					}
			   		newKode->bitHead=bitHeadCopy;	
				}
				//������� ��������� ����������� (������ � ������) ���
			   	bit * removeBit= bitHead;
				bitHead=bitHead->next;
				removeBit->next=NULL;
				delete removeBit;
		   	}
		}
		
		void deleteNodeFromList (node * deletingNode, node * head) //��� �� ����� delete ��� �������, head �� ����� ���� ��������� ���������
		{
			node *tmp=head;
			bool done=false;
			while ((tmp!=NULL)&&(!done))
			{
				if (tmp->next==deletingNode)
				{
					tmp->next=deletingNode->next;
					done=true;
				} 
				tmp=tmp->next;
			}
		}
};

int getInput(char input[],int size)
{
	for (int i=0;i<size;i++)
		input[i]='\0';
	cout<<"������� ������, ������� ����� �����������:\n";		
    fgets(input,size,stdin);
    int realInputSize;
    for (realInputSize=0;(input[realInputSize]!='\n')&&(input[realInputSize]!='\0');realInputSize++){};  // �� ���� ��� ������ �������� ������ \n, ��� ��� fgets ��������� �� � �����, �� ����� ����������������
    return realInputSize;
}

int main()
{
	SetConsoleOutputCP(1251);
	
	const int maxInputSize=256;
	char input[maxInputSize];
	const int realInputSize = getInput(input,maxInputSize);
	
	char string[realInputSize+1];
	memcpy(string, input, realInputSize);	
	string[realInputSize]='\0'; 
			
	haf_Tree tree;
	tree.makeTree(string,realInputSize);
	
	return 0;
}

